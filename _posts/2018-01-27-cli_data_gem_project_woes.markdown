---
layout: post
title:      "CLI Data Gem Project Woes"
date:       2018-01-28 02:31:04 +0000
permalink:  cli_data_gem_project_woes
---


The first problem I encountered was deciding on my gem. What was a unique but feasible idea? How to put it into practice and make sure it was something that was more than just a throwaway project? Which website(s) should I consider using because they don't change very frequently? I started with thinking hard about the examples given, but couldn't come up with anything particularly interesting that felt unique, or feasible (because this project really brought me up against my current limitations). I let the thought gestate for a bit, then was struck by inspiration. Something that even I might use at one point or another, but that wouldn't be something trying to solve a problem that I wasn't ready to tackle.

After coming up with the idea, I ran into the technical issue of unsuccessfully trying to use a Github repo that didn't automatically link to the Learn IDE. After some research (including reviewing currently open questions) and testing, I discovered that I could clone the repo into the main code section of the IDE (just not the labs folder nor a manually created "projects" folder). Luckily it only took a few hours to resolve this. I then discovered that though I understand the basics of Github, I hadn't needed to use it for a while and therefore needed to spend some time reacquainting myself with a complementary workflow, as well as looking up the specific commands. It certainly got easier as I forced myself to commit as many times as possible! 

As I worked, I started to get new ideas, but also realized that my idea was more complicated than I had initially expected. There were several points in which I realized that I could tweak my original idea to be more streamlined and simple, but decided to continue. Though I looked at and referenced the examples and walkthrough, I spent the majority of my time reviewing past labs and using online resources to address specific issues. It was somewhat of a fun project, though the pressure of it being a graded piece with code that I would need to explain certainly made it hard to focus at times. I would say that my greatest enemy throughout this project was my own mind. I am apparently notorious for making things more complicated than they need to be, yet my mind cannot seem to ever turn itself off. Often to the point of distraction, but usually just to the point where I need to step away from my computer for a bit to think things over from step one.

It was a bit startling and odd when everything was finally working. It definitely felt like product testing time, especially for interactive functionality and wording. As a point of habit, while working on a project, I tend to litter my code with comments and notes. That way I can jump around without having to remember exactly what I want each piece of code to do without reviewing everything surrounding it. I also often have to write down brief thoughts on how I could make the code more extensive or detailed or quicker so that I can actually leave the working section of code to continue on the overall functionality. After all, sometimes the focus and scope of the project doesn't require all of the little cosmetic and features that my mind can think up. Using Github and making a ton of commits certainly helped with my anxiety in that respect, since I knew that I didn't want to actually present my marked up code. Whenever writing code for something/someone else that I know they will be looking at, I always make sure to clean the code up for them. The marked up code is for my own thoughts, so I can explain why something is the way it is and retrieve thoughts I had in terms of code efficiency and expansion should it comes to that.

Update : Haha, I thought that I was done with this post and the project until I went to do the demo and realized that playtesting as that one annoying user who won't follow instructions or will purposefully try to break the programâ€¦ Caused my program to break a bit. Those bits have been fixed, but as I mentioned above, playtesting is definitely key when trying to create a stable and responsive program!

